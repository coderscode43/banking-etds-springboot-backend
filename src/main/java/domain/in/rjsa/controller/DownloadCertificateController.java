package domain.in.rjsa.controller;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.commons.compress.utils.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import domain.in.rjsa.dao.StaticDataDao;
import domain.in.rjsa.exception.CustomException;
import domain.in.rjsa.exception.FieldErrorDTO;
import domain.in.rjsa.model.form.StaticDataModel;
import domain.in.rjsa.model.fy.Logs;
import domain.in.rjsa.service.BranchService;
import domain.in.rjsa.service.LogsService;
import domain.in.rjsa.service.Regular24QDeducteeService;
import domain.in.rjsa.service.Regular26QDeducteeService;
import domain.in.rjsa.service.Regular27EQDeducteeService;
import domain.in.rjsa.service.Regular27QDeducteeService;
import domain.in.rjsa.util.StaticData;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import net.lingala.zip4j.exception.ZipException;

@Controller
@RequestMapping("/apidownloadCertificate")
public class DownloadCertificateController {

	@Autowired
	BranchService bService;

	@Autowired
	LogsService lservice;

	@Autowired
	Regular24QDeducteeService r24qService;

	@Autowired
	Regular26QDeducteeService r26qService;

	@Autowired
	Regular27QDeducteeService r27qService;

	@Autowired
	Regular27EQDeducteeService r27eqService;

	@Autowired
	private StaticDataDao staticDao;

	private static final String EXTENSION = "zip";
	private final Logger logger = LoggerFactory.getLogger(getClass());

	public HashSet<String> createZip = new HashSet<>();


	@Scheduled(fixedRate = 1800000) // 86400000 //3600000 //1800000
	private void createAutoGeneratedZip() {
		try {
			logger.info(
					"################################ Scheduler started for generateZip ################################");
			setStaticData();
			final long millisPerDay = 24 * 60 * 60 * 1000;
			HashSet<String> copyCreateZip = new HashSet<>(createZip);
			logger.info(copyCreateZip.toString());
			if (!copyCreateZip.isEmpty()) {
				for (String s : copyCreateZip) {
					String[] n = s.split(Pattern.quote("_"), -1);
					String t = n[0];
					String fy = n[1];
					String q = n[2];
					String c = n[3];
					String path = StaticData.CertificatePath;
					try {
						if (t.split(Pattern.quote("-"), -1)[0].equalsIgnoreCase("ALL TAN")) {
							String[] tanList = StaticData.Tan;
							String filePath = "";
							for (String tan : tanList) {
								filePath = path + "download/" + fy + "/" + q + "/" + c.split(Pattern.quote("-"), -1)[0]
										+ "/" + tan.split(Pattern.quote("-"), -1)[0];
								createZip(filePath, q, c, tan);
							}

							// Create All Tan Zip
							String tanPath = "";
							List<String> listFiles = new ArrayList<>();
							for (String tan : tanList) {
								tanPath = path + "download/" + fy + "/" + q + "/" + c.split(Pattern.quote("-"), -1)[0]
										+ "/" + tan.split(Pattern.quote("-"), -1)[0];
								CreateAllTanZip(listFiles, tanPath, q, c, s, tan);
							}
							if (!listFiles.isEmpty()) {
								tanPath = path + "download/" + fy + "/" + q + "/" + c.split(Pattern.quote("-"), -1)[0];
								packZip(listFiles,
										tanPath + "/ALL TAN_" + q + "_" + c.split(Pattern.quote("-"), -1)[0]);
							}

						} else {
							String filePath = path + "download/" + fy + "//" + q + "//"
									+ c.split(Pattern.quote("-"), -1)[0] + "//" + t.split(Pattern.quote("-"), -1)[0];
							File file = new File(filePath);
							if (file.exists()) {
								if (file.listFiles() != null) {
									List<String> listFiles = new ArrayList<>();
									for (File f : file.listFiles()) {
										if (f.getName().endsWith(".pdf")) {
											listFiles.add(f.getAbsolutePath());
										}
									}
									if (!listFiles.isEmpty()) {
										pack(listFiles, filePath);
									}
								}
							}
						}
						createZip.remove(s);
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void CreateAllTanZip(List<String> listFiles, String tanPath, String q, String c, String s, String tan) {
		try {
			File file = new File(tanPath);
			if (file.exists()) {
				if (file.listFiles() != null) {
					for (File f : file.listFiles()) {
						if (f.getName().endsWith(".zip")) {
							listFiles.add(f.getAbsolutePath());
						}

					}
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private void createZip(String filePath, String q, String c, String tan) {
		try {
			File file = new File(filePath);
			if (file.exists()) {
				if (file.listFiles() != null) {
					List<String> listFiles = new ArrayList<>();
					for (File f : file.listFiles()) {
						if (f.getName().endsWith(".pdf")) {
							listFiles.add(f.getAbsolutePath());
						}
					}
					if (!listFiles.isEmpty()) {
						pack(listFiles, filePath + "/" + tan.split(Pattern.quote("-"), -1)[0]);
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void pack(List<String> f, String destFolder) throws ZipException {
		try {
			FileOutputStream os = new FileOutputStream(destFolder + ".zip");
			ZipOutputStream zipOutputStream = new ZipOutputStream(os);
			for (String filePath : f) {
				File file = new File(filePath);
				// new zip entry and copying inputstream with file to zipOutputStream, after all
				// closing streams
				zipOutputStream.putNextEntry(new ZipEntry(file.getName().split(Pattern.quote("."), -1)[0] + ".pdf"));
				FileInputStream fileInputStream = new FileInputStream(file);
				IOUtils.copy(fileInputStream, zipOutputStream);
				fileInputStream.close();
				zipOutputStream.closeEntry();
//				logger.info(filePath);
			}
			logger.info(destFolder);
			zipOutputStream.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void packZip(List<String> f, String destFolder) throws ZipException {
		try {
			FileOutputStream os = new FileOutputStream(destFolder + ".zip");
			ZipOutputStream zipOutputStream = new ZipOutputStream(os);
			for (String filePath : f) {
				File file = new File(filePath);
				// new zip entry and copying inputstream with file to zipOutputStream, after all
				// closing streams
				zipOutputStream.putNextEntry(new ZipEntry(file.getName().split(Pattern.quote("."), -1)[0] + ".zip"));
				FileInputStream fileInputStream = new FileInputStream(file);
				IOUtils.copy(fileInputStream, zipOutputStream);
				fileInputStream.close();
				zipOutputStream.closeEntry();
//				logger.info(filePath);
			}
			logger.info(destFolder);
			zipOutputStream.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// XXXXXXXXXXXXXXXX Single Pan Download XXXXXXXXXXXXXXXXXXXXXXXXX
	@GetMapping(value = "/files/{tan}/{certificate}/{fy}/{q}/{pan}", produces = "application/octet-stream")
	public void download(HttpServletRequest request, HttpServletResponse response, @PathVariable String tan,
			@PathVariable String certificate, @PathVariable String fy, @PathVariable String q,
			@PathVariable String pan) {
		setStaticData();
		FieldErrorDTO ermsg = new FieldErrorDTO();
		try {
			String userName = getPrincipal();
			if (userName == null || "anonymousUser".equals(userName)) {
				String auth = request.getHeader("directDownloadAuth");
				if (auth != null) {
					if (auth.equals(StaticData.directDownloadAuth)) {
						logger.info("Direct download certificate through auth");
					} else {
						throw new Exception("Invalid AUTH");
					}
				} else {
					throw new Exception("Invalid AUTH");
				}
			}
			pan = pan.toUpperCase().trim();
			tan = tan.trim();
			// verify regx pan
			if (Pattern.matches("^[A-Z]{5}[0-9]{4}[A-Z]{1}$", pan) || pan.equalsIgnoreCase("ALL PAN")) {
				pan = pan;
			} else {
				logger.info("Invalid PAN");
				throw new Exception("Invalid PAN.");

			}
			// verify regx tan or if All TAN

			List<String> tanList = Arrays.asList(StaticData.Tan);
//			for (String t : tanList) {
//				logger.info(t+"^"+t.split(Pattern.quote("-"))[0]+"^"+tan);
			logger.info(tanList + "^" + tan);
			if (tanList.contains(tan) || tan.equalsIgnoreCase("ALL TAN")) {
				tan = tan;
			} else {
				logger.info("Invalid TAN");
				throw new Exception("Invalid TAN.");
			}
//			}
			// verify regX fy
			List<String> yearList = Arrays.asList(StaticData.financialYear);
			if (yearList.contains(fy)) {
				fy = fy;
			} else {
				logger.info("Invalid Financial Year");
				throw new Exception("Invalid Financial Year.");
			}
			// verify q
			List<String> qList = Arrays.asList(StaticData.Quarter);
			if (qList.contains(q) || q.equalsIgnoreCase("ALL QUARTER")) {
				q = q;
			} else {
				logger.info("Invalid Quarter");
				throw new Exception("Invalid Quarter.");
			}
			// verify certificate
			List<String> cList = Arrays.asList(StaticData.typeOfCertificate);
			for (String c : cList) {
				if (c.split(Pattern.quote("-"))[0].equalsIgnoreCase(certificate.split(Pattern.quote("-"))[0])) {
					certificate = certificate;
					break;
				} else if (StaticData.certificateType.contains(certificate.split(Pattern.quote("-"))[0])) {

				} else {
					logger.info("Invalid certificate");
					throw new Exception("Invalid Certificate.");
				}
			}
			String ay = fyToAy(fy);

			List<String> filesToSend = getAllFiles(fy, ay, q, certificate, tan, pan);
			System.out.println(filesToSend);
			if (filesToSend.isEmpty()) {
				// return no certificate found
				throw new Exception("No certificate found.");
			} else {
				// create zip and send the file also delete the file after sending
				response.setStatus(HttpServletResponse.SC_OK);
				response.addHeader("Content-Disposition", " attachment; filename=" + pan + "_" + fy + "_" + q + ".zip");
				response.setHeader("Content-Type", "application/zip");

				ZipOutputStream zipOutputStream = new ZipOutputStream(response.getOutputStream());
				int i = filesToSend.size();
				for (String filePath : filesToSend) {
					File file = new File(filePath);
					// new zip entry and copying inputstream with file to zipOutputStream, after all
					// closing streams
					zipOutputStream.putNextEntry(
							new ZipEntry(file.getName().split(Pattern.quote("."), -1)[0] + "_" + i + ".pdf"));
					FileInputStream fileInputStream = new FileInputStream(file);
					IOUtils.copy(fileInputStream, zipOutputStream);
					fileInputStream.close();
					zipOutputStream.closeEntry();
					i--;
					logger.info(filePath);
				}
				zipOutputStream.close();
				System.out.println("File Download");
				addLogs("Certificate");
			}

		} catch (Exception e) {
			// send dto object with error
			logger.info(e.getMessage());
			ermsg.setMessage("File not found for this PAN Number");
			ermsg.setExceptionMsg(e.getMessage());
			ermsg.setEntityName("Certificate");
			response.setStatus(400);
			ResponseEntity re = new ResponseEntity<Object>(ermsg, HttpStatus.BAD_REQUEST);
			try {
				response.getWriter().write(re.getBody().toString());
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

	}

	// XXXXXXXXXXXXXXXX Multiple Pan Download XXXXXXXXXXXXXXXXXXXXXXX
	@GetMapping(value = "/downloadMultiple/{tan}/{certificate}/{fy}/{q}/{pan}",produces = "application/octet-stream")
	public void multipleDownload(HttpServletRequest request, HttpServletResponse response, @PathVariable String tan,
			@PathVariable String certificate, @PathVariable String fy, @PathVariable String q,
			@PathVariable String pan) {
		setStaticData();
		FieldErrorDTO ermsg = new FieldErrorDTO();
		try {
			String userName = getPrincipal();
			if (userName == null || "anonymousUser".equals(userName)) {
				String auth = request.getHeader("directDownloadAuth");
				if (auth != null) {
					if (auth.equals(StaticData.directDownloadAuth)) {
						logger.info("Direct download certificate through auth");
					} else {
						throw new Exception("Invalid AUTH");
					}
				} else {
					throw new Exception("Invalid AUTH");
				}
			}
			List<String> listOfPan = new ArrayList<>();
			while (pan.length() >= 10) {
				String p = pan.substring(0, 10);
				// verify regx pan
				if (Pattern.matches("^[A-Z]{5}[0-9]{4}[A-Z]{1}$", p)) {
					listOfPan.add(p);
					pan = pan.substring(10, pan.length());
				} else {
					logger.info("Invalid PAN");
					pan = pan.substring(10, pan.length());
				}
			}
			tan = tan.trim();

// verify regx tan or if All TAN
			List<String> tanList = Arrays.asList(StaticData.Tan);
//				for (String t : tanList) {
//					logger.info(t+"^"+t.split(Pattern.quote("-"))[0]+"^"+tan);
			logger.info(tanList + "^" + tan);
			if (tanList.contains(tan) || tan.equalsIgnoreCase("ALL TAN")) {
				tan = tan;
			} else {
				logger.info("Invalid TAN");
				throw new Exception("Invalid TAN.");
			}
//				}
			// verify regX fy
			List<String> yearList = Arrays.asList(StaticData.financialYear);
			if (yearList.contains(fy)) {
				fy = fy;
			} else {
				logger.info("Invalid Financial Year");
				throw new Exception("Invalid Financial Year.");
			}
			// verify q
			List<String> qList = Arrays.asList(StaticData.Quarter);
			if (qList.contains(q) || q.equalsIgnoreCase("ALL QUARTER")) {
				q = q;
			} else {
				logger.info("Invalid Quarter");
				throw new Exception("Invalid Quarter.");
			}
			// verify certificate
			List<String> cList = Arrays.asList(StaticData.typeOfCertificate);
			for (String c : cList) {
				if (c.split(Pattern.quote("-"))[0].equalsIgnoreCase(certificate.split(Pattern.quote("-"))[0])) {
					certificate = certificate;
					break;
				} else if (StaticData.certificateType.contains(certificate.split(Pattern.quote("-"))[0])) {

				} else {
					logger.info("Invalid certificate");
					throw new Exception("Invalid Certificate.");
				}
			}
			String ay = fyToAy(fy);
			List<String> filesToSend = getAllCertificates(listOfPan, fy, ay, q, certificate,
					tan.split(Pattern.quote("-"), -1)[0]);
			System.out.println(filesToSend);
			if (filesToSend.isEmpty()) {
				// return no certificate found
				throw new Exception("No certificate found.");
			} else {
				// create zip and send the file also delete the file after sending
				response.setStatus(HttpServletResponse.SC_OK);
				response.addHeader("Content-Disposition",
						" attachment; filename=" + tan.split(Pattern.quote("-"), -1)[0] + "_" + fy + "_" + q + ".zip");
				response.setHeader("Content-Type", "application/zip");

				ZipOutputStream zipOutputStream = new ZipOutputStream(response.getOutputStream());
				int i = filesToSend.size();
				for (String filePath : filesToSend) {
					File file = new File(filePath);
					// new zip entry and copying inputstream with file to zipOutputStream, after all
					// closing streams
					zipOutputStream.putNextEntry(
							new ZipEntry(file.getName().split(Pattern.quote("."), -1)[0] + "_" + i + ".pdf"));
					FileInputStream fileInputStream = new FileInputStream(file);
					IOUtils.copy(fileInputStream, zipOutputStream);
					fileInputStream.close();
					zipOutputStream.closeEntry();
					i--;
					logger.info(filePath);
				}
				zipOutputStream.close();
				System.out.println("File Download");
				addLogs("Certificate");
			}

		} catch (Exception e) {
			// send dto object with error
			logger.info(e.getMessage());
			ermsg.setMessage("File not found for this PAN Numbers");
			ermsg.setExceptionMsg(e.getMessage());
			ermsg.setEntityName("Certificate");
			response.setStatus(400);
			ResponseEntity re = new ResponseEntity<Object>(ermsg, HttpStatus.BAD_REQUEST);
			try {
				response.getWriter().write(re.getBody().toString());
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

	}

	// XXXXXXXXXXXXXXXX Branch Zip Download XXXXXXXXXXXXXXXXXXXXXXXXX
	@GetMapping(value = "/downloadBranchZip/{tan}/{certificate}/{fy}/{q}/{branchCode}", produces = "application/octet-stream")
	public void downloadBranchZip(HttpServletRequest request, HttpServletResponse response,
			@PathVariable String branchCode, @PathVariable String certificate, @PathVariable String fy,
			@PathVariable String q, @PathVariable String tan) {
		setStaticData();
		FieldErrorDTO ermsg = new FieldErrorDTO();
		try {
			String userName = getPrincipal();
			if (userName == null || "anonymousUser".equals(userName)) {
				String auth = request.getHeader("directDownloadAuth");
				if (auth != null) {
					if (auth.equals(StaticData.directDownloadAuth)) {
						logger.info("Direct download certificate through auth");
					} else {
						throw new Exception("Invalid AUTH");
					}
				} else {
					throw new Exception("Invalid AUTH");
				}
			}
//			if (branchCode != "undefined" && branchCode != null) {
//				branchCode = branchCode.trim();
//				Branch branch = bService.getByKey(Long.valueOf(branchCode));
//				if (branch != null) {
//					branchCode = branchCode;
//				} else {
//					throw new Exception("Invalid Branch Code");
//				}
//			}
			// verify regx tan or if All TAN

			List<String> tanList = Arrays.asList(StaticData.Tan);
//									for (String t : tanList) {
//										logger.info(t+"^"+t.split(Pattern.quote("-"))[0]+"^"+tan);
			logger.info(tanList + "^" + tan);
			if (tanList.contains(tan) || tan.equalsIgnoreCase("ALL TAN")) {
				tan = tan;
			} else {
				logger.info("Invalid TAN");
				throw new Exception("Invalid TAN.");
			}
			// verify regX fy
			List<String> yearList = Arrays.asList(StaticData.financialYear);
			if (yearList.contains(fy)) {
				fy = fy;
			} else {
				throw new Exception("Invalid Financial Year.");
			}
			// vwerify q
			List<String> qList = Arrays.asList(StaticData.Quarter);
			if (qList.contains(q) || q.equalsIgnoreCase("ALL QUARTER")) {
				q = q;
			} else {
				throw new Exception("Invalid Quarter.");
			}
			// verify certificate
			List<String> cList = Arrays.asList(StaticData.typeOfCertificate);
			if (cList.contains(certificate)) {
				certificate = certificate;
			} else if (StaticData.certificateType.contains(certificate)) {

			} else {
				throw new Exception("Invalid Certificate.");
			}
			String[] c = certificate.split(Pattern.quote("-"), -1);
			String[] t = tan.split("-");
			String path = StaticData.CertificatePath;
			String fileName = t[0] + "_" + q + "_" + c[0] + ".zip";
			String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + fileName;
			if (!t[0].equalsIgnoreCase("All TAN")) {
				fileName = t[0] + ".zip";
				filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + fileName;
			}

			logger.info(filePath);
			File file = new File(filePath);
			if (file.exists()) {
				InputStream targetStream = new FileInputStream(file);
				response.setContentType("application/octet-stream");
				response.setStatus(HttpServletResponse.SC_OK);
				response.setHeader("Content-Disposition",
						" attachment; filename=" + t[0] + "_" + q + "_" + fy + ".zip");
				IOUtils.copy(targetStream, response.getOutputStream());
				targetStream.close();
				response.getOutputStream().close();
				System.out.println("File Downloaded");
				addLogs("Branch Certifiicate");
				ResponseEntity re = new ResponseEntity(HttpStatus.OK);
			} else {
				String fp = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0];
				file = new File(fp);
				if (file.exists()) {
					int count = file.listFiles().length;
					if (count > 0) {
						throw new CustomException("Generation of zip file in process, please check after sometime.");
					} else {
						throw new CustomException("Certificate not Available for this TAN Number.");
					}
				}
				throw new CustomException("Certificate not Available for this TAN Number.");
			}

		} catch (Exception e) {
			// send dto object with error
			response.setStatus(HttpServletResponse.SC_NOT_FOUND);
			ermsg.setMessage("Certificate not Available for this TAN Number.");
			ermsg.setExceptionMsg(e.getMessage());
			ermsg.setEntityName("Certificate");
			ResponseEntity re = new ResponseEntity(ermsg, HttpStatus.BAD_REQUEST);
			try {
				response.getWriter().write(re.getBody().toString());
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

	}

	// XXXXXXXXXXXXXXXX Create Branch Zip XXXXXXXXXXXXXXXXXXXXXXXXXXX
	@GetMapping(value = "/createBranchZip/{tan}/{certificate}/{fy}/{q}", produces = "application/octet-stream")
	public void createBranchZip(HttpServletRequest request, HttpServletResponse response, @PathVariable String tan,
			@PathVariable String certificate, @PathVariable String fy, @PathVariable String q) {
		setStaticData();
		FieldErrorDTO ermsg = new FieldErrorDTO();
		try {
			String userName = getPrincipal();
			if (userName == null || "anonymousUser".equals(userName)) {
				String auth = request.getHeader("directDownloadAuth");
				if (auth != null) {
					if (auth.equals(StaticData.directDownloadAuth)) {
						logger.info("Direct download certificate through auth");
					} else {
						throw new Exception("Invalid AUTH");
					}
				} else {
					throw new Exception("Invalid AUTH");
				}
			}

			// verify regx tan or if All TAN

			List<String> tanList = Arrays.asList(StaticData.Tan);
//						for (String t : tanList) {
//							logger.info(t+"^"+t.split(Pattern.quote("-"))[0]+"^"+tan);
			// verify regX fy
			List<String> yearList = Arrays.asList(StaticData.financialYear);
			if (yearList.contains(fy)) {
				fy = fy;
			} else {
				throw new Exception("Invalid Financial Year.");
			}
			// vwerify q
			List<String> qList = Arrays.asList(StaticData.Quarter);
			if (qList.contains(q) || q.equalsIgnoreCase("ALL QUARTER")) {
				q = q;
			} else {
				throw new Exception("Invalid Quarter.");
			}
			// verify certificate
			List<String> cList = Arrays.asList(StaticData.typeOfCertificate);
			if (cList.contains(certificate)) {
				certificate = certificate;
			} else if (StaticData.certificateType.contains(certificate)) {

			} else {
				throw new Exception("Invalid Certificate.");
			}
			String path = StaticData.CertificatePath; // ?????
			String[] c = certificate.split("-");
			String fileName = tan + "_" + fy + "_" + q + "_" + certificate;
			createZip.add(fileName);
			logger.info(createZip.toString());
		} catch (Exception e) {
			// send dto object with error
			logger.info(e.getMessage());
		}
	}

	private List<String> getAllCertificates(List<String> listOfPan, String fy, String ay, String q, String certificate,
			String tan) {
		List<String> filePaths = new ArrayList<>();
		for (String pan : listOfPan) {
			String path = StaticData.CertificatePath; // ?????
			String[] c = certificate.split("-");
			String[] t = tan.split("-");
			System.out.println(c[0] + "&&" + t[0]);
			Character ch = pan.charAt(4);

			if (tan.equals("ALL TAN") && q.equals("ALL QUARTER")) {
				for (String q1 : StaticData.Quarter) {
					for (String t1 : StaticData.Tan) {
						String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
						if (c[0].equalsIgnoreCase("Form16")) {
							pdfFileName = pan + "_" + ay + ".pdf";
						}
						t = t1.split("-");
						String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
								+ pdfFileName;
						logger.info(filePath);
						addFileIfExist(filePath, filePaths);
					}
				}
			} else if (tan.equals("ALL TAN")) {
				for (String t1 : StaticData.Tan) {
					String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
					if (c[0].equalsIgnoreCase("Form16")) {
						pdfFileName = pan + "_" + ay + ".pdf";
					}
					t = t1.split("-");
					String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
							+ pdfFileName;
					logger.info(filePath);
					addFileIfExist(filePath, filePaths);
				}

			} else if (q.equals("ALL QUARTER")) {
				for (String q1 : StaticData.Quarter) {
					String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
					if (c[0].equalsIgnoreCase("Form16")) {
						pdfFileName = pan + "_" + ay + ".pdf";
					}
					String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
							+ pdfFileName;
					logger.info(filePath);
					addFileIfExist(filePath, filePaths);
				}
			} else {
				String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
				if (c[0].equalsIgnoreCase("Form16")) {
					pdfFileName = pan + "_" + ay + ".pdf";
				}
				String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
						+ pdfFileName;
				logger.info(filePath);
				addFileIfExist(filePath, filePaths);
			}

			if (filePaths.isEmpty()) {
				if (tan.equals("ALL TAN") && q.equals("ALL QUARTER")) {
					for (String q1 : StaticData.Quarter) {
						for (String t1 : StaticData.Tan) {
							t = t1.split("-");
							String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
							if (c[0].equalsIgnoreCase("Form16")) {
								pdfFileName = pan + "_" + ay + ".pdf";
							}
							String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/"
									+ pdfFileName;
							logger.info(filePath);
							addFileIfExist(filePath, filePaths);
						}
					}
				} else if (tan.equals("ALL TAN")) {
					for (String t1 : StaticData.Tan) {
						t = t1.split("-");
						String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
						if (c[0].equalsIgnoreCase("Form16")) {
							pdfFileName = pan + "_" + ay + ".pdf";
						}
						String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/"
								+ pdfFileName;
						logger.info(filePath);
						addFileIfExist(filePath, filePaths);
					}

				} else if (q.equals("ALL QUARTER")) {
					for (String q1 : StaticData.Quarter) {
						String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
						if (c[0].equalsIgnoreCase("Form16")) {
							pdfFileName = pan + "_" + ay + ".pdf";
						}
						String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/"
								+ pdfFileName;
						logger.info(filePath);
						addFileIfExist(filePath, filePaths);
					}
				} else {
					String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
					if (c[0].equalsIgnoreCase("Form16")) {
						pdfFileName = pan + "_" + ay + ".pdf";
					}
					String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + pdfFileName;
					logger.info(filePath);
					addFileIfExist(filePath, filePaths);
				}
			}
		}
		return filePaths;
	}

	private List<String> getAllFiles(String fy, String ay, String q, String certificate, String tan, String pan) {

		List<String> filePaths = new ArrayList<String>();

		String path = StaticData.CertificatePath;
		String[] c = certificate.split("-");
		String[] t = tan.split("-");
		System.out.println(c[0] + "&&" + t[0]);
		Character ch = pan.charAt(4);

		if (tan.equals("ALL TAN") && q.equals("ALL QUARTER")) {
			for (String q1 : StaticData.Quarter) {
				for (String t1 : StaticData.Tan) {
					String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
					if (c[0].equalsIgnoreCase("Form16")) {
						pdfFileName = pan + "_" + ay + ".pdf";
					}
					t = t1.split("-");
					String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
							+ pdfFileName;
					logger.info(filePath);
					addFileIfExist(filePath, filePaths);
				}
			}
		} else if (tan.equals("ALL TAN")) {
			for (String t1 : StaticData.Tan) {
				String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
				if (c[0].equalsIgnoreCase("Form16")) {
					pdfFileName = pan + "_" + ay + ".pdf";
				}
				t = t1.split("-");
				String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
						+ pdfFileName;
				logger.info(filePath);
				addFileIfExist(filePath, filePaths);
			}

		} else if (q.equals("ALL QUARTER")) {
			for (String q1 : StaticData.Quarter) {
				String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
				if (c[0].equalsIgnoreCase("Form16")) {
					pdfFileName = pan + "_" + ay + ".pdf";
				}
				String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
						+ pdfFileName;
				logger.info(filePath);
				addFileIfExist(filePath, filePaths);
			}
		} else {
			String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
			if (c[0].equalsIgnoreCase("Form16")) {
				pdfFileName = pan + "_" + ay + ".pdf";
			}
			String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + ch + "/"
					+ pdfFileName;
			logger.info(filePath);
			addFileIfExist(filePath, filePaths);
		}
		if (filePaths.isEmpty()) {
			if (tan.equals("ALL TAN") && q.equals("ALL QUARTER")) {
				for (String q1 : StaticData.Quarter) {
					for (String t1 : StaticData.Tan) {
						t = t1.split("-");
						String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
						if (c[0].equalsIgnoreCase("Form16")) {
							pdfFileName = pan + "_" + ay + ".pdf";
						}
						String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/"
								+ pdfFileName;
						logger.info(filePath);
						addFileIfExist(filePath, filePaths);
					}
				}
			} else if (tan.equals("ALL TAN")) {
				for (String t1 : StaticData.Tan) {
					t = t1.split("-");
					String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
					if (c[0].equalsIgnoreCase("Form16")) {
						pdfFileName = pan + "_" + ay + ".pdf";
					}
					String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + pdfFileName;
					logger.info(filePath);
					addFileIfExist(filePath, filePaths);

				}

			} else if (q.equals("ALL QUARTER")) {
				for (String q1 : StaticData.Quarter) {
					String pdfFileName = pan + "_" + q1 + "_" + ay + ".pdf";
					if (c[0].equalsIgnoreCase("Form16")) {
						pdfFileName = pan + "_" + ay + ".pdf";
					}
					String filePath = path + "download/" + fy + "/" + q1 + "/" + c[0] + "/" + t[0] + "/" + pdfFileName;
					logger.info(filePath);
					addFileIfExist(filePath, filePaths);
				}
			} else {
				String pdfFileName = pan + "_" + q + "_" + ay + ".pdf";
				if (c[0].equalsIgnoreCase("Form16")) {
					pdfFileName = pan + "_" + ay + ".pdf";
				}
				String filePath = path + "download/" + fy + "/" + q + "/" + c[0] + "/" + t[0] + "/" + pdfFileName;
				logger.info(filePath);
				addFileIfExist(filePath, filePaths);
			}
		}

		return filePaths;
	}

	private void addFileIfExist(String filePath, List<String> filePaths) {
		if (new File(filePath).exists()) {
			System.out.println(filePath);
			logger.info(filePath);
			filePaths.add(filePath);
		}
	}

	public String fyToAy(String fy) {
		String[] yr = fy.split("-");
		int y1 = Integer.parseInt(yr[0]);
		int y2 = Integer.parseInt(yr[1]);
		int Ay1 = y1 + 1;
		int Ay2 = y2 + 1;
		return Ay1 + "-" + Ay2;

	}

	public String getPrincipal() {
		String userName = null;
		Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		if (principal instanceof UserDetails) {
			userName = ((UserDetails) principal).getUsername();
		} else {
			userName = principal.toString();
		}
		return userName;
	}

	protected String getIp() {
		try {
			InetAddress ipAddr = InetAddress.getLocalHost();
			String str = ipAddr.getHostAddress();
			return str;
		} catch (UnknownHostException ex) {
			ex.printStackTrace();

			return null;
		}
	}

	public void addLogs(String Action) {
		Logs log = new Logs();
		log.setAction("Download");
		log.setIpaddrs(getIp());
		log.setLogsDate(new Date(System.currentTimeMillis()));
		log.setUsername("anonymousUser".equals(getPrincipal()) ? "directdownload" : getPrincipal());
		log.setEntity("Download " + Action);
		lservice.save(log);
	}

	private void setStaticData() {
		if (StaticData.ClientName == null) {
			HashMap<String, Object> sd = new HashMap<String, Object>();
			List<StaticDataModel> list = staticDao.findall(sd, 0, 100);
			String[] stringArray;
			String xString;
			for (StaticDataModel list1 : list) {
				String key = list1.getKey();
				switch (key) {
				case "financialYear":
					xString = list1.getValue();
					stringArray = xString.split(",");
					StaticData.financialYear = stringArray;
					break;
				case "typeOfCertificate":
					xString = list1.getValue();
					stringArray = xString.split(",");
					StaticData.typeOfCertificate = stringArray;
					break;
				case "Quarter":
					xString = list1.getValue();
					stringArray = xString.split(",");
					StaticData.Quarter = stringArray;
					break;
				case "Tan":
					xString = list1.getValue();
					stringArray = xString.split(",");
					StaticData.Tan = stringArray;
					break;
				case "directDownload":
					xString = list1.getValue();
					StaticData.directDownloadAuth = xString;
					break;
				case "CertificatePath":
					xString = list1.getValue();
					StaticData.CertificatePath = xString;
					break;	
				default:
					break;
				}
			}
		}
	}
}
